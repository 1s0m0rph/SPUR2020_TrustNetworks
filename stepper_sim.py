"""
General idea: we want to figure out how well our algorithms work on an actual network with distributed parallel computation. We could literally build such a network, but that would be difficult and likely time-consuming. Thus, instead, we'll build a time-step based simulation to run computations concurrently in a sort of simulation
"""

from TN import *

#it's rewind time

'''
transform G st vanilla max flow will count the paths correctly

this we do by adding, for each node with in-degree > 1 and out-degree >1, a dummy node (called a "fork" node)
that the original node points to and moving all of the original node's out-edges to be the out-edges of the fork node
'''
def vertex_disjoint_transform(G):
	Gp = nx.DiGraph()
	Gp.add_edges_from(G.edges)#copy G

	for v in list(Gp.nodes):#cast to list so that there are no concurrent modification issues
		#for every vertex
		if (Gp.in_degree(v) > 1) and (Gp.out_degree(v) > 1):#with in and out degree > 1 (forking vertex)
			#do the motif transform
			fork_node = 'f{}'.format(v)
			#assign all of v's out-edges to f* and remove them from v
			for u in list(Gp.neighbors(v)):#cast to list so that there are no concurrent modification issues
				Gp.add_edge(fork_node,u)
				Gp.remove_edge(v,u)
			#point v to the fork node
			Gp.add_edge(v,fork_node)

	#assign capacity 1 to all edges
	nx.set_edge_attributes(Gp,1,name='capacity')

	return Gp

'''
use max flow on a modified version of G to find the number of vertex disjoint paths between s and t
'''
def vertex_disjoint_paths(G,s,t):
	#first modify G so that two-in two-out motifs evaluate correctly
	Gp = vertex_disjoint_transform(G)
	#then run max flow on that graph with the caveat that if we used the fork node transform on s we need to change the start to s
	if 'f{}'.format(s) in Gp.nodes:
		s = 'f{}'.format(s)

	return nx.algorithms.flow.edmonds_karp(Gp,s,t).graph['flow_value']

class TNNode_Stepper(TNNode):

	"""
	A version of TNNode that is compatible with stepper-simulations

	general function format:
		needs to return a list of all the function calls generated by the function (fn,args,kwargs) as well as a callback for processing once all subcalls have returned
	"""

	def __init__(self,node_id):
		super().__init__(node_id)

		self.time = 0#this will be used to make sure no function calls happen prematurely
		self.operations = []#queue of operations we need to perform (fn,args,kwargs)
		self.paths = []#maintained at the object level to make callbacks easier

		#info for s (search starter)
		self.neighbors_to_call = []
		# self.pulse_num = 0
		self.initial_TTL = float('inf')
		self.is_search_originator = False
		self.search_dest = None
		self.search_dest_coords = None


	def __repr__(self):
		return 'SSTNN {}'.format(self.id)

	'''
	do all of the operations in our queue (we assume that if the time for those operations hasn't come yet according to our clock, the function we call will automatically not perform them)
	'''
	def increment_time(self):
		#self.time += 1
		this_step_operations = self.operations.copy()
		self.operations.clear()
		self.operations_done += len(this_step_operations)
		for fn, args, kwargs, callback in this_step_operations:
			ret = fn(*args, **kwargs)
			callback(ret)


	def count_vd_paths_to_v2_callback(self,path):
		if path is not None:
			self.paths.append(path)
			#TODO: logic for sending out more pulses?
			#if len(self.neighbors_to_call) > 0:
				#self.pulse_num += 1
				#self.neighbors_to_call.pop(0).v2_vd_paths_interm_synchronized(path[-1].id,self,self.pulse_num,self.time + 1,self.count_vd_paths_to_v2_callback,self.initial_TTL)

	def cleanup(self):
		#now reset pulse numbers and blacklist flags
		for n in self.neighbors:
			n.reset_search()

		self.search_blacklist_flag = False
		self.is_search_originator = False

	'''
	2nd naive version of vertex-disjoint path count algorithm between s (this/self) and t
	this version runs until no paths are found and can return the found paths for verification of VD property
	
	additions:
		TTL (time-to-live): enforces the cutting off of distant nodes to reduce the total computation done on the network
		shadowing paths: t will check all pings that arrive to see if they're valid paths
	'''
	def count_vd_paths_to_v2(self,dest_id,return_paths=True,TTL=float('inf')):
		self.search_blacklist_flag = True
		self.initial_TTL = TTL#TODO: adaptive TTL?
		#start a search to dest from each neighbor
		pulse_num = 0
		#self.neighbors_to_call = list(self.neighbors)
		for neighbor in self.neighbors:
			neighbor.v2_vd_paths_interm_synchronized(dest_id,self,pulse_num,self.time + 1,self.count_vd_paths_to_v2_callback,TTL-1)
			pulse_num += 1


	'''
	do another graph search to reset pulse numbers
	'''
	def reset_search(self):
		if self.resetted_flag:
			#we're done here
			return

		#otherwise set our predecessor, reset our number, and tell all our neighbors to reset
		self.resetted_flag = True
		self.pulse_pred = {}
		self.search_blacklist_flag = False
		self.is_search_originator = False
		self.search_dest = None
		self.search_dest_coords = None

		for n in self.neighbors:
			n.reset_search()

	'''
	someone has asked me to find dest
	'''
	def v2_vd_paths_interm_synchronized(self,dest_id,pred,pulse_num,time,callback,TTL):
		if time > self.time:
			#then we need to postpone processing this part until our time is updated
			self.operations.append((self.v2_vd_paths_interm_synchronized,[dest_id,pred,pulse_num,time,callback,TTL],{},callback))
			return None

		if TTL <= 0:
			return None#we're at the maximum distance from s

		if self.id == dest_id:#this has to happen before the visited check to implement path shadowing
			#blacklist nodes on this path
			self.pulse_pred.update({pulse_num:pred})
			self.resetted_flag = False
			self.search_blacklist_flag = False#t is never blacklisted, but the function after sets it to be so
			path = self.v2_vd_blacklist_zip(pulse_num,[])
			return path

		if pulse_num in self.pulse_pred:
			return None#we've already been visited in this search

		if self.search_blacklist_flag:
			return None#we are already blacklisted (or have been visited in this search), so don't go this way

		#we've relayed this pulse now
		self.pulse_pred.update({pulse_num:pred})
		self.resetted_flag = False

		#otherwise ask all our neighbors if they know the muffin man
		for n in self.neighbors:
			path = n.v2_vd_paths_interm_synchronized(dest_id,self,pulse_num,time + 1,callback,TTL-1)
			if path is not None:
				return path

		return None

	'''
	I am on the path to dest from s, so I need to be blacklisted

	this method also reconstructs the path, mostly for verification
	'''
	def v2_vd_blacklist_zip(self,pulse_num,path: list):
		if pulse_num not in self.pulse_pred:
			return path#this could also return the reconstructed path, but would require more data to be passed between nondes

		if self.search_blacklist_flag:
			#then this won't work, we need to unblacklist everything in the path
			for node in path:
				node.search_blacklist_flag = False

			#and return no path
			return None

		self.search_blacklist_flag = True
		return self.pulse_pred[pulse_num].v2_vd_blacklist_zip(pulse_num,[self] + path)